
[一陈子期一]  知道你是胖 猪，垃圾箱的 贱 货 ，屁股后几个没教养的小混混，和一元一次的失足女。打不过侠客轩，可怜憋屈的PVBBBBBBBBbbbb

2015-9-30 重新开始 设计，保证完成设计

=================== 快捷设置  ==========================
设置书签  ctr+z
F1 -- help
 F2 下一书签   F3 查找   F4 选择字符串 
 F5       启动调试

ctr+alt+m 提取一段代码块，生成一个新的方法 

undo   ctr+shift+z

F6:-- Ctrl+F10: 运行到光标处       生成解决方案 
F7 -- ReSharper_FindUsages    查看变量的使用
F8 -- 调试。重新启动
F9: - 停止调试
F10: 逐过程      F11: 逐语句          
F12

Ctrl + B 跳到变 量申明处  转跳到定义，很有用的快捷键
Ctrl + w 折叠到定义  new



Shift+F7: 查看窗体设计器 

Ctrl+F5: 开始执行(不调试) 
Shift+F5: 停止调试 
Ctrl+Shift+F5: 重启调试 

Ctrl+F9: 启用/停止断点 
Ctrl+Shift+F9: 删除全部断点 

F12: 转到所调用过程或变量的定义 
Ctrl+E+F就自动整理齐 

 检测 dataRow 行数据是否有空
           for   ( i = 0; i < 27; i++)  datarow
                {
                    if (string.IsNullOrEmpty(r[i].ToString()))
                    {
                        r[i] = "";
                    }
                }

--------------------------------------------------------------
来宾信息查询
结账明细查询
消费退单明显查询
历史进店/离店查询
结账单消费查询
收银明细查询
更换房间信息查询
客人消费查询

日/月营业查询
日/月营业统计
营业统计排行
房类销售分析
入住率统计
综合统计报表
消费分类统计


日营业分析
月营业分析
年营业分析
客源分析 
消费品分析

---------------------------------------------------------------------------
     TimeSpan span1 = dateTime - NowDateTime;
用时间 2 减时间 1，得到一个 TimeSpan 实例。
---------------------------------------------------------------------------
     DialogResult dr = MessageBox.Show("确定退出本系统吗？", "提示信息", MessageBoxButtons.YesNo, MessageBoxIcon.Question);
                 if (dr == DialogResult.No)       {              e.Cancel = true;
                 }
                 else //退出系统
                 {
               //      e.CloseReason = 0;
---------------------------------10-17----------------------------------------------
    //       RichTextBox rtb = new RichTextBox();     // 动态定义  控件 不能用与文件读写！！！！
----------------------------------------------------------------
分离截取  string 字符串
public string Substring(      int startIndex,      int length  )

--------------------------------------------------------------------
listview  显示行数据
             DestineTable = SqlHelp.ExcuteAsAdapter("select * from Destine");
                foreach (DataRow r in DestineTable.Rows) //取 房间预订
                {
                    var item = new ListViewItem();
                    listView1.Items.Add(item);
                    item.Tag = r["DestineId"];
                    item.Text = r["GuestName"].ToString();
                    item.SubItems.Add(r["ydtime"].ToString());
                    item.SubItems.Add(r["Phone"].ToString());
                }





--------------------  dateTimePicker3 ----------------------------------

  时间相加减       DateTime t1 = Convert.ToDateTime(dateTimePicker1.Text);
            this.dateTimePicker3.Text = t1.AddHours(1).ToString("yyyy年MM月dd日 HH时mm分");
-------------------------------------------------------------
     protected bool IsNumberic(string message, out int result) //判断是否为整数字符串
        {
            //是的话则将其转换为数字并将其设为out类型的输出值、返回true, 否则为false
            result = -1; //result 定义为out 用来输出值
            try
            {
                //当数字字符串的为是少于4时，以下三种都可以转换，任选一种
                //如果位数超过4的话，请选用Convert.ToInt32() 和int.Parse()

                //result = int.Parse(message);
                //result = Convert.ToInt16(message);
                result = Convert.ToInt32(message);
                return true;
            }
            catch
            {
                return false;
            }
        }

--------------------------------------------------------------------------
 DialogResult    resault = MessageBox.Show("您没有选择会员是否退出？", "提示", MessageBoxButtons.YesNo);      
               if (resault == DialogResult.Yes)
-----------------按输入关键字查询 listview 项的匹配--------------------
    for (int i = 0; i < listView3.Items.Count; i++) {               {
                   if (listView3.Items[i].SubItems[1].Text == textBox14.Text.Trim()) 
                   {
                       if (first)
                       {
                           listView3.Items[i].Focused = true;
                           listView3.Items[i].Selected = true;
                           listView3.Items[i].EnsureVisible();
                           this.listView3.Items[i].BackColor = Color.DeepSkyBlue;//选定状态﹐为蓝色
                           first = false;

10-11 -------//单击listview 行事件 选择行数据-----------
    private void listView3_SelectedIndexChanged(object sender, EventArgs e)  
       {
           if ( listView3.SelectedIndices.Count > 0)
           {
               ListView.SelectedIndexCollection c = listView3.SelectedIndices;
               string ss = listView3.Items[c[0]].Text;   // 编号
     //          string ss1 = listView3.Items[c[0]].SubItems[1].ToString();
               string ss3 = listView3.FocusedItem.SubItems[1].Text;
      }}

10-8 ：类中的方法 用static 静态属性 在在其他类中可以不用实例化 有静态类中的方法---


-----------------------  C#DataTable学习心得-------------
一、DataSet、DataTable、DataRow、DataColumn
1】 在DataSet中添加DataTable
     DataSet.Tables.Add(DataTable) 
实例：
　　　　DataSet ds=new DataSet();
　　　　DataTable table=new DataTable("学生表");
　　　　ds.Tables.Add(table);
2】从DataSet中读出DataTable
     DataTable=DataSet.Tables[0]或DataSet.Tables["表名"] 
实例：
　　　　DataTable table=ds[i]或DataTable table=ds["学生表"]

　　　　//i为DataSet中的索引值，因为DataSet可存放多个DataTable，可以根据索引值来找DataTable或直接写DataTable的名称来找DataTable
3】添加行
     DataTable t=new DataTable();
     DataRow r=t.NewRow();
     r["列名"]=列值;
     t.Rows.Add(r) ;

实例：
　　　　DataTable：学生表
　　　　id　　　　name
　　　　1　　　　xun
代码：

　　　　DataTable t=new DataTable("学生表");
　　　　DataRow r=t.NewRow();
　　　　r["id"]=2;
　　　　r["name"]=xun2;
　　　　t.Rows.Add(r);

4】添加列

     DataTable.Columns.Add("列名",Type.GetType("数据类型"))  ;
5】从行中读列值

     DataRow["列名"]或DataRow[DataColumn];  
6】从DataTable中读列值

    DataTable table;

    a、table.Rows[i]["列名"]

    b、table.Rows[i][i]

    c、table[i].列名(列名不加引号)

7】读出特定的行

    DataTable table;

    DataRow[] selectRow=table.Select("列名='"+存放特定的变量.ToString()+"'");

    选择其中的一行：selectRow[索引]

二、删除DataTable中的行三种方法：（DataTable.Rows.Remove(DataRow dr)、DataTable.Rows.RemoveAt(i)、DataRow.Delete()）

删除DataTable中的行要注意索引问题，一般有两种方法：
1】用for循环时，注意计数器初始值为表长，自减循环。DataTable.Rows.RemoveAt(i)就要注意。
2】用DataTable的Select方法，注意该方法的参数是字符串筛选器
3】Delete()之后需要datatable.AccepteChanges()方法确认完全删除，因为Delete()只是将相应列的状态标志为删除，还可以通过datatable.RejectChanges()回滚，使该行取消删除。若要删除多行，可以连续用Delete()，然后采用AccepteChanges()方法确认删除。

分类: C#随笔


------------combobox 使用 数据源 -----------------------
string cmdText = "SELECT ID, Name FROM 表1"; 
SqlConnection conn = new SqlConnection(连接字符串); 
conn.Open(); 
SqlDataAdapter da = new SqlDataAdapter(cmdText, conn); 
DataSet ds = new DataSet(); 
da.Fill(ds, "IdName"); 
//绑定 
comboBox1.DisplayMember = "ID";    //显示的值 
comboBox1.ValueMember = "Name";    //实际的值 
comboBox1.DataSource = ds.Tables["IdName"]; 
 
在comboBox1_SelectedIndexChanged事件中用 
string a = comboBox1.SelectedValue.ToString(); 
---------------------------------------------------------------
本地变量 小写字母打头   2015-10-5
listview  点击空白 处用 mousedown 事件

-----------------------------------------------------------
1 数值型转换为字符型

数值型数据转换为字符串用ToString()方法即可实现

int num1=10
string mynum=num1.ToString();

2 字符串转换为数值型

字符串数据转换为数值型使用Pares()方法
字符串转换为整型用int.Pares()

string str="13";
int number=int.Pares(str);
字符串转换为双精度浮点型  double.Pares()string

string str="14";
double number =double.Pares(str);

字符串转换为单精度浮点型  float.Parse(string)

string str="15";
float number=float.Pares(str);
  

9-31
 txtCardId.Select();  //设定 文本输入框 光标
  this.ActiveControl = txtCardId;
---------------------------------------------------------------
              if ((int)e.KeyChar < 48 || (int)e.KeyChar > 57)  //只允许输入数字
            {
                e.Handled = true;
-------------------------------------------------------------
//只输入数字和 退格键
       private void txtPaid_KeyPress(object sender, KeyPressEventArgs e)  //只输入数字和 退格键
        {
            int a = (int)e.KeyChar;
            if (a == 8 || (a >= 48 && a <= 57))
            {
            }
            else
            {
                e.Handled = true;
            }
        }
	-------------------------------------------------
   tabControl4.SelectedIndex = 1;  //选择 不同 选项卡
   tabControl1.SelectedTab 可以获取选中的TabPage对象。tabControl1.SelectedIndex 可以获取选中的TabPage对象的索引号。
   如果你是判断选择的是哪个，用selectindex还不错。 

   string.format大全   http://www.cnblogs.com/tangjian/archive/2009/03/28/1423897.html

9-5
#region    已经完成程序

#endregion

c#如何调用其他类的方法

如果是静态方法的话 直接类名.方法名就可以  
普通的方法 就实例化 该类 然后实例名.方法名
main：
    var frm11 = new FrmaddDeposit(this);
            frm11.ShowDialog();
subprg:
      public FrmMain Frmmain;   //FrmMain  
    public FrmaddDeposit(FrmMain frmain)
        {
            this.Frmmain = frmain;
            InitializeComponent();
        }



9-21  ----- 根据需要ListView中的特定行采用不同的颜色突出显示
    item.UseItemStyleForSubItems = false; //this line makes things work 
      item.SubItems.Add(string.Format("{0:F2}", max), Color.Red, Color.AliceBlue, Font);

选择listview2 的每行事件
     private void listView2_ItemSelectionChanged(object sender, ListViewItemSelectionChangedEventArgs e)  // 
        {
            ListViewItem aa = e.Item;
            _RoomName = aa.SubItems[9].Text.Trim(); // 获取房间号
            if (_RoomName != "")
            {
                var rs = new FrmDeposi();
                rs.ShowDialog();
            }

treeview  树目录操作 还是用这个事件 可以选择相应 节点
   private void treeView2_AfterSelect(

----------------------------数据库插入-----------------------------------------------------
INSERT INTO Deposit   (Time, Room, Name, Cash) VALUES ('2014-9-14 08:23:30', '8801', 'www', 10)

      int roomid = Convert.ToInt32(row["RoomId"]);
	  MessageBox.Show("", "提示");
      DialogResult dr = MessageBox.Show("你确定要结账吗？", "提示", MessageBoxButtons.OKCancel, MessageBoxIcon.Question);
            if (dr == DialogResult.OK)
       outputStr = string.Format("select * FROM RoomType WHERE (RoomTypeId = (SELECT RoomTypeId FROM Room WHERE (RoomId = {0})))",roomid);
                            DataTable dataTable = SqlHelp.ExcuteAsAdapter(outputStr);
                            string rentcost = string.Format("{0:F2}", Convert.ToDouble(dataTable.Rows[0]["PriceOfToday"]));  // 挂牌单价
                            double turecost = Convert.ToDouble(dataTable.Rows[0]["PriceOfVIP"]);   //实际成交价      
                            int intRentRoomInfoId = Convert.ToInt32(row["RentRoomInfoId"]);
                            string times = NowDateTime.ToString("yyyy-MM-dd HH:mm:ss");
                            string sql = string.Format("update RentRoom set RentRoomOrder='{0}', RentCost={1},RentDurationUnit='天',RentDuration=1, LastEditDate='{2}' where RentRoomInfoId={3}",turecost,rentcost,times,intRentRoomInfoId );
                            SqlHelp.ExcuteInsertUpdateDelete(sql);
                            string s = string.Format("主房号:{0}宾客姓名:{1}",row["RoomName"].ToString(),row["GuestName"].ToString());
                            sql = string.Format("insert into SystemLog values ('{0}','{1}','钟点房改全天房','{2}','{3}','')", times, AppInfo._UserName, s, times);//  记录 钟点房 事件
                            SqlHelp.ExcuteInsertUpdateDelete(sql);
	
          DateTime dateTime = Convert.ToDateTime(_roomdt.Rows[0]["RentTime"].ToString());

数据库 select 按 roomname 递增排序 
   string sql2 = "select * from Room r inner join RoomType rt on r.RoomTypeId=rt.RoomTypeId inner join
    RoomState rs on r.RoomStateId=rs.RoomStateId ORDER BY RoomName";   //ORDER BY RoomName  14-8-20

dt.Rows[0]["RoomTypeName"].
_sql = string.Format("update Room Set RoomStateId=2 where RoomName='{0}'", item.SubItems[1].Text); //改变房间状态
    SqlHelp.ExcuteInsertUpdateDelete(_sql);



---------------------------C#中遍历TreeView并查找和选定节点  ---------------------------------------
         TreeNodeCollection nodes = treeView2.Nodes;  // 遍历TreeView并查找和选定节点  
            if (e.KeyChar == 13)  //  retrun 回车键
            {
                foreach (TreeNode tn2 in nodes)
                {
                    if (tn2.Text == textBox5.Text)
                    {
                        tn2.Checked = true;
                        tn2.ForeColor = Color.Red;
                        if (_lastNode != null)
                        {
                            _lastNode.ForeColor = Color.Black;
                        }
                        _lastNode = tn2;
                        treeView2.SelectedNode = tn2;
                        return;
                    }
                }
            }
挂单结账，余额在paid
 string.Format("{0:F2}", );// 显示押金
  DialogResult dr;
    dr = MessageBox.Show("你确定挂单吗？", "提示", MessageBoxButtons.OKCancel, MessageBoxIcon.Question);
    if (dr == DialogResult.OK)
    {
        goto jmpp;
    }

DATEDIFF 函数 [日期和时间]功能 
返回两个日期之间的间隔。语法 
DATEDIFF ( date-part, date-expression-1, date-expression-2 )date-part :
year | quarter | month | week | day | hour | minute | second | millisecond参数 
date-part    指定要测量其间隔的日期部分。有关日期部分的详细信息，请参见日期部分。
date-expression-1    某一间隔的起始日期。从 date-expression-2 中减去该值，返回
两个参数之间 date-parts 的天数。date-expression-2    某一间隔的结束日期。从该值
中减去 Date-expression-1，返回两个参数之间 date-parts 的天数。用法 
此函数计算两个指定日期之间日期部分的数目。结果为日期部分中等于（date2 - date1）
的有符号的整数值。当结果不是日期部分的偶数倍时，DATEDIFF 将被截断而不是被舍入。
当使用 day 作为日期部分时，DATEDIFF 返回两个指定的时间之间（包括第二个日期但
不包括第一个日期）的午夜数。当使用 month 作为日期部分时，DATEDIFF 返回两个
日期之间（包括第二个日期但不包括第一个日期）出现的月的第一天的数目。当使用
 week 作为日期部分时，DATEDIFF 返回两个日期（包括第二个日期但不包括第一个日期）
 之间星期日的数目。对于更小的时间单位存在溢出值：milliseconds    24 天 seconds  
   68 年 minutes    4083 年 others    没有溢出限制 如果超出这些限制，此函数将
   返回溢出错误。标准和兼容性 
SQL/92    Transact-SQL 扩展。 SQL/99    Transact-SQL 扩展。 Sybase  
  与 Adaptive Server Enterprise 兼容。
  下面示例的语句返回 1：SELECT datediff( hour, '4:00AM', '5:50AM' )
  下面的语句返回 102：SELECT datediff( month, '1987/05/02', '1995/11/15' )
  下面的语句返回 0：SELECT datediff( day, '00:00', '23:59' )下面的语句返回 
  4：SELECT datediff( day,   '1999/07/19 00:00',   '1999/07/23 23:59' )
  下面的语句返回 0：SELECT datediff( month, '1999/07/19', '1999/07/23' )下面的语句返回 1：
	SELECT datediff( month, '1999/07/19', '1999/08/23' )
	datediff()
	select datediff(mm,'2009-10-1',getdate())--
	
	------------------1select datediff(dd,'2009-10-1',getdate())------------
	
31(1 行受影响)

                SqlCommand cmd = new SqlCommand("select * from tbtest where datetimenow='"+new DateTime(2011,1,1,19,20,2).
				ToString("yyyy-MM-dd HH:mm:ss")+"'",con);
                    Console.WriteLine(cmd.ExecuteReader().HasRows);

1	可供
2	入住
3	清扫
4	预定
5	长包
6	停用
10-2 增加钟点房押金  ，处理 押金增加减少

姓名和身份证号码	性别	年龄	所属地区
庾帅成 232721196812088039	男	46	黑龙江省 大兴安岭地区 呼玛县
崔寄翠 230606197710149383	女	37	黑龙江省 大庆市 大同区
刁苗 620826196906158446	女	45	甘肃省
陈修勇 360321197410214450	男	40	江西省 萍乡市 莲花县
邱润国 410523198203236457	男	32	河南省 安阳市 汤阴县
鲍振华 350501197605053339	男	38	福建省 泉州市 市辖区
洪恒宏 411322196407261771	男	50	河南省 南阳市 方城县
妍伊 42060019860617306X	女	28	湖北省 襄樊市 襄樊市
贺瑶恒 469006197106094919	男	43	海南省
桂宝 130928198606306348	女	28	河北省 沧州市 吴桥县
吴璨 220524199002023047	女	24	吉林省 通化市 柳河县
查增霞 230902197405311701	女	40	黑龙江省 七台河市 新兴区
锺子淳 341125196604115597	男	48	安徽省 滁州市 定远县
井星慰 340828197201149013	男	42	安徽省 安庆市 岳西县
唐利 469034196402107236	男	50	海南省
余冬梅 230403198510133269	女	29	黑龙江省 鹤岗市 工农区
弘芷波 433126196903060047	女	45	湖南省 湘西土家族苗族自治州 古丈县
戚思娴 330185198809180723	女	26	浙江省 杭州市 临安市
和梦玉 511722197208092661	女	42	四川省
禹玟 41108219690427897X	男	45	河南省 许昌市 长葛市
盛贤洋 522223198611022379	男	28	贵州省 铜仁地区 玉屏侗族自治县
奚新华 231121198409164594	男	30	黑龙江省 黑河市 嫩江县
党玲幸 130638198904082481	女	25	河北省 保定市 雄县
扶丹琴 431129198205184700	女	32	湖南省 永州市 江华瑶族自治县
苗小丫 361102198604183205	女	28	江西省
郦乐意 620423197609134302	女	38	甘肃省 白银市 景泰县
喻明强 131003196208237194	男	52	河北省 廊坊市
栾慧玲 429000197407119766	女	40	湖北省 省直辖行政单位 省直辖行政单位
岑安寒 140723199009279365	女	24	山西省
党凌寒 511526198703078989	女	27	四川省 宜宾市 珙县









http://lfstar.blog.163.com/blog/static/563789872010027326285/

			
在.net 编程环境中，系统的资源分为托管资源和非托管资源。

　　对于托管的资源的回收工作，是不需要人工干预回收的，而且你也无法干预他们的回收，所能够做的

只是了解.net CLR如何做这些操作。也就是说对于您的应用程序创建的大多数对象，可以依靠 .NET

Framework 的垃圾回收器隐式地执行所有必要的内存管理任务。

　　对于非托管资源，您在应用程序中使用完这些非托管资源之后，必须显示的释放他们，例如

System.IO.StreamReader的一个文件对象，必须显示的调用对象的Close()方法关闭它，否则会占用系统

的内存和资源，而且可能会出现意想不到的错误。

　　我想说到这里，一定要清楚什么是托管资源，什么是非托管资源了？

　　最常见的一类非托管资源就是包装操作系统资源的对象，例如文件，窗口或网络连接，对于这类资源

虽然垃圾回收器可以跟踪封装非托管资源的对象的生存期，但它不了解具体如何清理这些资源。还好.net

Framework提供了Finalize()方法，它允许在垃圾回收器回收该类资源时，适当的清理非托管资源。如果

在MSDN Library 中搜索Finalize将会发现很多类似的主题，这里列举几种常见的非托管资源：

ApplicationContext,Brush,Component,ComponentDesigner,Container,Context,Cursor,FileStream,Fon

t,Icon,Image,Matrix,Object,OdbcDataReader,OleDBDataReader,Pen,Regex,Socket,StreamWriter,Time

r,Tooltip 等等资源。可能在使用的时候很多都没有注意到！

关于托管资源，就不用说了撒，像简单的int,string,float,DateTime等等，.net中超过80%的资源都是托

管资源。

非托管资源如何释放，.NET Framework 提供 Object.Finalize 方法，它允许对象在垃圾回收器回收该对象
使用的内存时适当清理其非托管资源。默认情况下，Finalize 方法不执行任何操作。如果您要让垃圾回收器
在回收对象的内存之前对对象执行清理操作，您必须在类中重写 Finalize 方法。然而大家都可以发现在实际
的编程中根本无法override方法Finalize(),在C#中，可以通过析构函数自动生成 Finalize 方法和对基类的 Finalize 方法的调用。


例如：
~MyClass()
{
　　// Perform some cleanup operations here.
}
　　该代码隐式翻译为下面的代码。
protected override void Finalize()
{
　　try
　　{
　　　　// Perform some cleanup operations here.
　　}
　　finally
　　{
　　　　base.Finalize();
　　}
}

但是，在编程中，并不建议进行override方法Finalize()，因为，实现 Finalize 方法或析构函数对性能

可能会有负面影响。一个简单的理由如下：用 Finalize 方法回收对象使用的内存需要至少两次垃圾回收

，当垃圾回收器回收时，它只回收没有终结器(Finalize方法)的不可访问的内存，这时他不能回收具有终

结器(Finalize方法)的不可以访问的内存。它改为将这些对象的项从终止队列中移除并将他们放置在标记

为“准备终止”的对象列表中，该列表中的项指向托管堆中准备被调用其终止代码的对象，下次垃圾回收



器进行回收时，就回收并释放了这些内存。

C#中的object类深入理解

 C#中所有的类都直接或间接继承自System.Object类，这使得C#中的类得以单根继承。如果我们没有明确指定继承类，编译器缺省认为该类继承自System.Object类。System.Object类也可用小写的object关键字表示，两者完全等同。自然C#中所有的类都继承了System.Object类的公共接口，剖析它们对我们理解并掌握C#中类的行为非常重要。下面是仅用接口形式表示的System.Object类： 
 
namespace System
{
    public class Object
    {
        public static bool Equals(object objA,object objB){}
        public static bool ReferenceEquals(object objA,object objB){}
 
        public Object(){}
 
        public virtual bool Equals(object obj){}
        public virtual int GetHashCode(){}
        public Type GetType(){}
        public virtual string ToString(){}
 
        protected virtual void Finalize(){}
        protected object MemberwiseClone(){}
    }
 
    我们先看object的两个静态方法Equals(object objA,object objB)，ReferenceEquals(object objA,object objB)和一个实例方法Equals(object obj)。在我们阐述这两个方法之前我们首先要清楚面向对象编程两个重要的相等概念：值相等和引用相等。值相等的意思是它们的数据成员按内存位分别相等。引用相等则是指它们指向同一个内存地址，或者说它们的对象句柄相等。引用相等必然推出值相等。对于值类型关系等号“==”判断两者是否值相等（结构类型和枚举类型没有定义关系等号“==”，我们必须自己定义）。对于引用类型关系等号“==”判断两者是否引用相等。值类型在C#里通常没有引用相等的表示，只有在非托管编程中采用取地址符“&”来间接判断二者的地址是否相等。 
 
     静态方法Equals(object objA,object objB)首先检查两个对象objA和objB是否都为null，如果是则返回true，否则进行objA.Equals(objB)调用并返回其值。问题归结到实例方法Equals(object obj)。该方法缺省的实现其实就是{return this= =obj;}也就是判断两个对象是否引用相等。但我们注意到该方法是一个虚方法，C#推荐我们重写此方法来判断两个对象是否值相等。实际上Microsoft.NET框架类库内提供的许多类型都重写了该方法，如：System.String（string），System.Int32（int）等，但也有些类型并没有重写该方法如：System.Array等，我们在使用时一定要注意。对于引用类型，如果没有重写实例方法Equals(object obj)，我们对它的调用相当于this= =obj，即引用相等判断。所有的值类型（隐含继承自System.ValueType类）都重写了实例方法Equals(object obj)来判断是否值相等。 
 
     注意对于对象x，x.Equals(null)返回false，这里x显然不能为null（否则不能完成Equals()调用，系统抛出空引用错误）。从这里我们也可看出设计静态方法Equals(object objA,object objB)的原因了--如果两个对象objA和objB都可能为null，我们便只能用object. Equals(object objA,object objB)来判断它们是否值相等了--当然如果我们没有改写实例方法Equals(object obj)，我们得到的仍是引用相等的结果。我们可以实现接口IComparable来强制改写实例方法Equals(object obj)。 
 
      对于值类型，实例方法Equals(object obj)应该和关系等号“==”的返回值一致，也就是说如果我们重写了实例方法Equals(object obj)，我们也应该重载或定义关系等号“==”操作符，反之亦然。虽然值类型（继承自System.ValueType类）都重写了实例方法Equals(object obj)，但C#推荐我们重写自己的值类型的实例方法Equals(object obj)，因为系统的System.ValueType类重写的很低效。对于引用类型我们应该重写实例方法Equals(object obj)来表达值相等，一般不应该重载关系等号“==”操作符，因为它的缺省语义是判断引用相等。 
 
      静态方法ReferenceEquals(object objA,object objB)判断两个对象是否引用相等。如果两个对象为引用类型，那么它的语义和没有重载的关系等号“==”操作符相同。如果两个对象为值类型，那么它的返回值一定是false。 
 
      实例方法GetHashCode()为相应的类型提供哈希（hash）码值，应用于哈希算法或哈希表中。需要注意的是如果我们重写了某类型的实例方法Equals(object obj)，我们也应该重写实例方法GetHashCode()--这理所应当，两个对象的值相等，它们的哈希码也应该相等。下面的代码是对前面几个方法的一个很好的示例： 
 
using System;
struct A
{
    public int count;
}
class B
{
    public int number;
}
class C
{
    public int integer=0;
    public override bool Equals(object obj)
    {
        C c=obj as C;
        if (c!=null)
            return this.integer==c.integer;
        else
            return false;
    }
    public override int GetHashCode()
    {
        return 2^integer;
    }
}
class Test
{
    public static void Main()
    {
        A a1,a2;
        a1.count=10;
        a2=a1;
 
        //Console.Write(a1==a2);没有定义“==”操作符
        Console.Write(a1.Equals(a2));//True
Console.WriteLine(object.ReferenceEquals(a1,a2));//False
 
        B b1=new B();
        B b2=new B();
 
        b1.number=10;
        b2.number=10;
        Console.Write(b1==b2);//False
        Console.Write(b1.Equals(b2));//False
Console.WriteLine(object.ReferenceEquals(b1,b2));//False
 
        b2=b1;
        Console.Write(b1==b2);//True
        Console.Write(b1.Equals(b2));//True
        Console.WriteLine(object.ReferenceEquals(b1,b2));//True
 
        C c1=new C();
        C c2=new C();
 
        c1.integer=10;
        c2.integer=10;
        Console.Write(c1==c2);//False
        Console.Write(c1.Equals(c2));//True
Console.WriteLine(object.ReferenceEquals(c1,c2));//False
 
        c2=c1;
        Console.Write(c1==c2);//True
        Console.Write(c1.Equals(c2));//True
        Console.WriteLine(object.ReferenceEquals(c1,c2));//True
    }
}
 
如我们所期望，编译程序并运行我们会得到以下输出： 
 
     True   False 
     False  False  False 
     True   True   True 
     False  True   False 
     True   True   True  
 
      实例方法GetType()与typeof的语义相同，它们都通过查询对象的元数据来确定对象的运行时类型，我们在“第十讲 特征与映射”对此作详细的阐述。 
 
     实例方法ToString()返回对象的字符串表达形式。如果我们没有重写该方法，系统一般将类型名作为字符串返回。 
 
      受保护的Finalize()方法在C#中有特殊的语义，我们将在“第五讲 构造器与析构器”里详细阐述。 
 
      受保护的MemberwiseClone()方法返回目前对象的一个“影子拷贝”，该方法不能被子类重写。“影子拷贝”仅仅是对象的一份按位拷贝，其含义是对对象内的值类型变量进行赋值拷贝，对其内的引用类型变量进行句柄拷贝，也就是拷贝后的引用变量将持有对同一块内存的引用。相对于“影子拷贝”的是深度拷贝，它对引用类型的变量进行的是值复制，而非句柄复制。例如X是一个含有对象A,B引用的对象，而对象A又含有对象M的引用。Y是X的一个“影子拷贝”。那么Y将拥有同样的A,B的引用。但对于X的一个“深度拷贝”Z来说，它将拥有对象C和D的引用，以及一个间接的对象N的引用，其中C是A的一份拷贝，D是B的一份拷贝，N是M的一份拷贝。深度拷贝在C#里通过实现ICloneable接口（提供Clone()方法）来完成。 
 ============================================================================================================
http://blog.csdn.net/dajian790626/article/details/17153037

  经典SQL语句大全
分类： SQL语句 2011-08-19 00:29 938人阅读 评论(1) 收藏 举报
sqltable服务器数据库sql serversqlserver
一、基础
1、说明：创建数据库
CREATE DATABASE database-name 
2、说明：删除数据库
drop database dbname
3、说明：备份sql server
--- 创建 备份数据的 device
USE master
EXEC sp_addumpdevice 'disk', 'testBack', 'c:\mssql7backup\MyNwind_1.dat'
--- 开始 备份
BACKUP DATABASE pubs TO testBack
4、说明：创建新表
create table tabname(col1 type1 [not null] [primary key],col2 type2 [not null],..)
根据已有的表创建新表： 
A：create table tab_new like tab_old (使用旧表创建新表)
B：create table tab_new as select col1,col2… from tab_old definition only
5、说明：删除新表
drop table tabname
6、说明：增加一个列
Alter table tabname add column col type
注：列增加后将不能删除。DB2中列加上后数据类型也不能改变，唯一能改变的是增加varchar类型的长度。
7、说明：添加主键： Alter table tabname add primary key(col)
说明：删除主键： Alter table tabname drop primary key(col) 
8、说明：创建索引：create [unique] index idxname on tabname(col….)
删除索引：drop index idxname
注：索引是不可更改的，想更改必须删除重新建。
9、说明：创建视图：create view viewname as select statement
删除视图：drop view viewname
10、说明：几个简单的基本的sql语句
选择：select * from table1 where范围
插入：insert into table1(field1,field2) values(value1,value2)
删除：delete from table1 where 范围
更新：update table1 set field1=value1 where范围
查找：select * from table1 where field1 like ’%value1%’ ---like的语法很精妙，查资料!
排序：select * from table1 order by field1,field2 [desc]
总数：select count as totalcount from table1
求和：select sum(field1) as sumvalue from table1
平均：select avg(field1) as avgvalue from table1
最大：select max(field1) as maxvalue from table1
最小：select min(field1) as minvalue from table1
11、说明：几个高级查询运算词
A： UNION 运算符
UNION 运算符通过组合其他两个结果表（例如 TABLE1 和 TABLE2）并消去表中任何重复行而派生出一个结果表。当 ALL 随 UNION 一起使用时（即 UNION ALL），不消除重复行。两种情况下，派生表的每一行不是来自 TABLE1 就是来自 TABLE2。
B： EXCEPT 运算符
EXCEPT 运算符通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。
C： INTERSECT运算符
INTERSECT 运算符通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当ALL随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。
注：使用运算词的几个查询结果行必须是一致的。
12、说明：使用外连接
A、left （outer） join：
左外连接（左连接）：结果集几包括连接表的匹配行，也包括左连接表的所有行。
SQL: select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c
B：right （outer） join: 
右外连接(右连接)：结果集既包括连接表的匹配连接行，也包括右连接表的所有行。
C：full/cross （outer） join：
全外连接：不仅包括符号连接表的匹配行，还包括两个连接表中的所有记录。
12、分组:Group by:
   一张表，一旦分组 完成后，查询后只能得到组相关的信息。
    组相关的信息：（统计信息） count,sum,max,min,avg 分组的标准)
    在SQLServer中分组时：不能以text,ntext,image类型的字段作为分组依据
   在selecte统计函数中的字段，不能和普通的字段放在一起；
13、对数据库进行操作：
   分离数据库： sp_detach_db; 附加数据库：sp_attach_db后接表明，附加需要完整的路径名
14.如何修改数据库的名称:
sp_renamedb 'old_name', 'new_name'
 
二、提升
1、说明：复制表(只复制结构,源表名：a 新表名：b) (Access可用)
法一：select * into b from a where 1<>1（仅用于SQlServer）
法二：select top 0 * into b from a
2、说明：拷贝表(拷贝数据,源表名：a 目标表名：b) (Access可用)
insert into b(a, b, c) select d,e,f from b;
3、说明：跨数据库之间表的拷贝(具体数据使用绝对路径) (Access可用)
insert into b(a, b, c) select d,e,f from b in ‘具体数据库’ where 条件
例子：..from b in '"&Server.MapPath(".")&"\data.mdb" &"' where..
4、说明：子查询(表名1：a 表名2：b)
select a,b,c from a where a IN (select d from b ) 或者: select a,b,c from a where a IN (1,2,3)
5、说明：显示文章、提交人和最后回复时间
select a.title,a.username,b.adddate from table a,(select max(adddate) adddate from table where table.title=a.title) b
6、说明：外连接查询(表名1：a 表名2：b)
select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c
7、说明：在线视图查询(表名1：a )
select * from (SELECT a,b,c FROM a) T where t.a > 1;
8、说明：between的用法,between限制查询数据范围时包括了边界值,not between不包括
select * from table1 where time between time1 and time2
select a,b,c, from table1 where a not between 数值1 and 数值2
9、说明：in 的使用方法
select * from table1 where a [not] in (‘值1’,’值2’,’值4’,’值6’)
10、说明：两张关联表，删除主表中已经在副表中没有的信息
delete from table1 where not exists ( select * from table2 where table1.field1=table2.field1 )
11、说明：四表联查问题：
select * from a left inner join b on a.a=b.b right inner join c on a.a=c.c inner join d on a.a=d.d where .....
12、说明：日程安排提前五分钟提醒
SQL: select * from 日程安排 where datediff('minute',f开始时间,getdate())>5
13、说明：一条sql语句搞定数据库分页
select top 10 b.* from (select top 20主键字段,排序字段 from表名 order by 排序字段 desc) a,表名 b where b.主键字段 = a.主键字段 order by a.排序字段
具体实现：
关于数据库分页：
  declare @start int,@end int
  @sql  nvarchar(600)
  set @sql=’select top’+str(@end-@start+1)+’+from T where rid not in(select top’+str(@str-1)+’Rid from T where Rid>-1)’
  exec sp_executesql @sql

注意：在top后不能直接跟一个变量，所以在实际应用中只有这样的进行特殊的处理。Rid为一个标识列，如果top后还有具体的字段，这样做是非常有好处的。因为这样可以避免 top的字段如果是逻辑索引的，查询的结果后实际表中的不一致（逻辑索引中的数据有可能和数据表中的不一致，而查询时如果处在索引则首先查询索引）
14、说明：前10条记录
select top 10 * form table1 where 范围
15、说明：选择在每一组b值相同的数据中对应的a最大的记录的所有信息(类似这样的用法可以用于论坛每月排行榜,每月热销产品分析,按科目成绩排名,等等.)
select a,b,c from tablename ta where a=(select max(a) from tablename tb where tb.b=ta.b)
16、说明：包括所有在 TableA 中但不在 TableB和TableC中的行并消除所有重复行而派生出一个结果表
(select a from tableA ) except (select a from tableB) except (select a from tableC)
17、说明：随机取出10条数据
select top 10 * from tablename order by newid()
18、说明：随机选择记录
select newid()
19、说明：删除重复记录
1),delete from tablename where id not in (select max(id) from tablename group by col1,col2,...)
2),select distinct * into temp from tablename
  delete from tablename
  insert into tablename select * from temp
评价： 这种操作牵连大量的数据的移动，这种做法不适合大容量但数据操作
3),例如：在一个外部表中导入数据，由于某些原因第一次只导入了一部分，但很难判断具体位置，这样只有在下一次全部导入，这样也就产生好多重复的字段，怎样删除重复字段
alter table tablename
--添加一个自增列
add  column_b int identity(1,1)
 delete from tablename where column_b not in(
select max(column_b)  from tablename group by column1,column2,...)
alter table tablename drop column column_b
20、说明：列出数据库里所有的表名
select name from sysobjects where type='U' // U代表用户
21、说明：列出表里的所有的列名
select name from syscolumns where id=object_id('TableName')
22、说明：列示type、vender、pcs字段，以type字段排列，case可以方便地实现多重选择，类似select 中的case。
select type,sum(case vender when 'A' then pcs else 0 end),sum(case vender when 'C' then pcs else 0 end),sum(case vender when 'B' then pcs else 0 end) FROM tablename group by type
显示结果：
type vender pcs
电脑 A 1
电脑 A 1
光盘 B 2
光盘 A 2
手机 B 3
手机 C 3
23、说明：初始化表table1
TRUNCATE TABLE table1
24、说明：选择从10到15的记录
select top 5 * from (select top 15 * from table order by id asc) table_别名 order by id desc
三、技巧
1、1=1，1=2的使用，在SQL语句组合时用的较多
“where 1=1” 是表示选择全部    “where 1=2”全部不选，
如：
if @strWhere !='' 
begin
set @strSQL = 'select count(*) as Total from [' + @tblName + '] where ' + @strWhere
end
else 
begin
set @strSQL = 'select count(*) as Total from [' + @tblName + ']' 
end
我们可以直接写成
错误！未找到目录项。
set @strSQL = 'select count(*) as Total from [' + @tblName + '] where 1=1安定 '+ @strWhere 2、收缩数据库
--重建索引
DBCC REINDEX
DBCC INDEXDEFRAG
--收缩数据和日志
DBCC SHRINKDB
DBCC SHRINKFILE
3、压缩数据库
dbcc shrinkdatabase(dbname)
4、转移数据库给新用户以已存在用户权限
exec sp_change_users_login 'update_one','newname','oldname'
go
5、检查备份集
RESTORE VERIFYONLY from disk='E:\dvbbs.bak'
6、修复数据库
ALTER DATABASE [dvbbs] SET SINGLE_USER
GO
DBCC CHECKDB('dvbbs',repair_allow_data_loss) WITH TABLOCK
GO
ALTER DATABASE [dvbbs] SET MULTI_USER
GO
7、日志清除
SET NOCOUNT ON
DECLARE @LogicalFileName sysname,
 @MaxMinutes INT,
 @NewSize INT

USE tablename -- 要操作的数据库名
SELECT  @LogicalFileName = 'tablename_log', -- 日志文件名
@MaxMinutes = 10, -- Limit on time allowed to wrap log.
 @NewSize = 1  -- 你想设定的日志文件的大小(M)
Setup / initialize
DECLARE @OriginalSize int
SELECT @OriginalSize = size 
 FROM sysfiles
 WHERE name = @LogicalFileName
SELECT 'Original Size of ' + db_name() + ' LOG is ' + 
 CONVERT(VARCHAR(30),@OriginalSize) + ' 8K pages or ' + 
 CONVERT(VARCHAR(30),(@OriginalSize*8/1024)) + 'MB'
 FROM sysfiles
 WHERE name = @LogicalFileName
CREATE TABLE DummyTrans
 (DummyColumn char (8000) not null)

DECLARE @Counter    INT,
 @StartTime DATETIME,
 @TruncLog   VARCHAR(255)
SELECT @StartTime = GETDATE(),
 @TruncLog = 'BACKUP LOG ' + db_name() + ' WITH TRUNCATE_ONLY'
DBCC SHRINKFILE (@LogicalFileName, @NewSize)
EXEC (@TruncLog)
-- Wrap the log if necessary.
WHILE @MaxMinutes > DATEDIFF (mi, @StartTime, GETDATE()) -- time has not expired
 AND @OriginalSize = (SELECT size FROM sysfiles WHERE name = @LogicalFileName)  
 AND (@OriginalSize * 8 /1024) > @NewSize  
 BEGIN -- Outer loop.
SELECT @Counter = 0
 WHILE   ((@Counter < @OriginalSize / 16) AND (@Counter < 50000))
 BEGIN -- update
 INSERT DummyTrans VALUES ('Fill Log') DELETE DummyTrans
 SELECT @Counter = @Counter + 1
 END
 EXEC (@TruncLog)  
 END
SELECT 'Final Size of ' + db_name() + ' LOG is ' +
 CONVERT(VARCHAR(30),size) + ' 8K pages or ' + 
 CONVERT(VARCHAR(30),(size*8/1024)) + 'MB'
 FROM sysfiles 
 WHERE name = @LogicalFileName
DROP TABLE DummyTrans
SET NOCOUNT OFF
8、说明：更改某个表
exec sp_changeobjectowner 'tablename','dbo'
9、存储更改全部表
CREATE PROCEDURE dbo.User_ChangeObjectOwnerBatch
@OldOwner as NVARCHAR(128),
@NewOwner as NVARCHAR(128)
AS
DECLARE @Name    as NVARCHAR(128)
DECLARE @Owner   as NVARCHAR(128)
DECLARE @OwnerName   as NVARCHAR(128)
DECLARE curObject CURSOR FOR 
select 'Name'    = name,
   'Owner'    = user_name(uid)
from sysobjects
where user_name(uid)=@OldOwner
order by name
OPEN   curObject
FETCH NEXT FROM curObject INTO @Name, @Owner
WHILE(@@FETCH_STATUS=0)
BEGIN     
if @Owner=@OldOwner 
begin
   set @OwnerName = @OldOwner + '.' + rtrim(@Name)
   exec sp_changeobjectowner @OwnerName, @NewOwner
end
-- select @name,@NewOwner,@OldOwner
FETCH NEXT FROM curObject INTO @Name, @Owner
END
close curObject
deallocate curObject
GO

10、SQL SERVER中直接循环写入数据
declare @i int
set @i=1
while @i<30
begin
    insert into test (userid) values(@i)
    set @i=@i+1
end
案例：
有如下表，要求就裱中所有沒有及格的成績，在每次增長0.1的基礎上，使他們剛好及格:
    Name     score
    Zhangshan   80
    Lishi       59
    Wangwu      50
    Songquan    69
while((select min(score) from tb_table)<60)
begin
update tb_table set score =score*1.01
where score<60
if  (select min(score) from tb_table)>60
  break
 else
    continue
end
 
数据开发-经典

1.按姓氏笔画排序:
Select * From TableName Order By CustomerName Collate Chinese_PRC_Stroke_ci_as //从少到多
2.数据库加密:
select encrypt('原始密码')
select pwdencrypt('原始密码')
select pwdcompare('原始密码','加密后密码') = 1--相同；否则不相同 encrypt('原始密码')
select pwdencrypt('原始密码')
select pwdcompare('原始密码','加密后密码') = 1--相同；否则不相同
3.取回表中字段:
declare @list varchar(1000),
@sql nvarchar(1000) 
select @list=@list+','+b.name from sysobjects a,syscolumns b where a.id=b.id and a.name='表A'
set @sql='select '+right(@list,len(@list)-1)+' from 表A'
exec (@sql)
4.查看硬盘分区:
EXEC master..xp_fixeddrives
5.比较A,B表是否相等:
if (select checksum_agg(binary_checksum(*)) from A)
     =
    (select checksum_agg(binary_checksum(*)) from B)
print '相等'
else
print '不相等'
6.杀掉所有的事件探察器进程:
DECLARE hcforeach CURSOR GLOBAL FOR SELECT 'kill '+RTRIM(spid) FROM master.dbo.sysprocesses
WHERE program_name IN('SQL profiler',N'SQL 事件探查器')
EXEC sp_msforeach_worker '?'
7.记录搜索:
开头到N条记录
Select Top N * From表
-------------------------------
N到M条记录(要有主索引ID)
Select Top M-N * From 表 Where ID in (Select Top M ID From表) Order by ID   Desc
----------------------------------
N到结尾记录
Select Top N * From表 Order by ID Desc
案例
例如1：一张表有一万多条记录，表的第一个字段 RecID 是自增长字段， 写一个SQL语句， 找出表的第31到第40个记录。
 select top 10 recid from A where recid not  in(select top 30 recid from A)
分析：如果这样写会产生某些问题，如果recid在表中存在逻辑索引。
    select top 10 recid from A where……是从索引中查找，而后面的select top 30 recid from A则在数据表中查找，这样由于索引中的顺序有可能和数据表中的不一致，这样就导致查询到的不是本来的欲得到的数据。
解决方案
1， 用order by select top 30 recid from A order by ricid如果该字段不是自增长，就会出现问题
2，在那个子查询中也加条件：select top 30 recid from A where recid>-1
例2：查询表中的最后以条记录，并不知道这个表共有多少数据,以及表结构。
set @s = 'select top 1 * from T   where pid not in (select top ' + str(@count-1) + ' pid  from  T)'
print @s      exec  sp_executesql  @s
9：获取当前数据库中的所有用户表
select Name from sysobjects where xtype='u' and status>=0
10：获取某一个表的所有字段
select name from syscolumns where id=object_id('表名')
select name from syscolumns where id in (select id from sysobjects where type = 'u' and name = '表名')
两种方式的效果相同
11：查看与某一个表相关的视图、存储过程、函数
select a.* from sysobjects a, syscomments b where a.id = b.id and b.text like '%表名%'
12：查看当前数据库中所有存储过程
select name as 存储过程名称 from sysobjects where xtype='P'
13：查询用户创建的所有数据库
select * from master..sysdatabases D where sid not in(select sid from master..syslogins where name='sa')
或者
select dbid, name AS DB_NAME from master..sysdatabases where sid <> 0x01
14：查询某一个表的字段和数据类型
select column_name,data_type from information_schema.columns
where table_name = '表名'
15：不同服务器数据库之间的数据操作
--创建链接服务器
exec sp_addlinkedserver   'ITSV ', ' ', 'SQLOLEDB ', '远程服务器名或ip地址 '
exec sp_addlinkedsrvlogin  'ITSV ', 'false ',null, '用户名 ', '密码 '
--查询示例
select * from ITSV.数据库名.dbo.表名
--导入示例
select * into 表 from ITSV.数据库名.dbo.表名
--以后不再使用时删除链接服务器
exec sp_dropserver  'ITSV ', 'droplogins '
 
--连接远程/局域网数据(openrowset/openquery/opendatasource)
--1、openrowset
--查询示例
select * from openrowset( 'SQLOLEDB ', 'sql服务器名 '; '用户名 '; '密码 ',数据库名.dbo.表名)
--生成本地表
select * into 表 from openrowset( 'SQLOLEDB ', 'sql服务器名 '; '用户名 '; '密码 ',数据库名.dbo.表名)
 
--把本地表导入远程表
insert openrowset( 'SQLOLEDB ', 'sql服务器名 '; '用户名 '; '密码 ',数据库名.dbo.表名)
select *from 本地表
--更新本地表
update b
set b.列A=a.列A
 from openrowset( 'SQLOLEDB ', 'sql服务器名 '; '用户名 '; '密码 ',数据库名.dbo.表名)as a inner join 本地表 b
on a.column1=b.column1
--openquery用法需要创建一个连接
--首先创建一个连接创建链接服务器
exec sp_addlinkedserver   'ITSV ', ' ', 'SQLOLEDB ', '远程服务器名或ip地址 '
--查询
select *
FROM openquery(ITSV,  'SELECT *  FROM 数据库.dbo.表名 ')
--把本地表导入远程表
insert openquery(ITSV,  'SELECT *  FROM 数据库.dbo.表名 ')
select * from 本地表
--更新本地表
update b
set b.列B=a.列B
FROM openquery(ITSV,  'SELECT * FROM 数据库.dbo.表名 ') as a 
inner join 本地表 b on a.列A=b.列A
 
--3、opendatasource/openrowset
SELECT   *
FROM   opendatasource( 'SQLOLEDB ',  'Data Source=ip/ServerName;User ID=登陆名;Password=密码 ' ).test.dbo.roy_ta
--把本地表导入远程表
insert opendatasource( 'SQLOLEDB ',  'Data Source=ip/ServerName;User ID=登陆名;Password=密码 ').数据库.dbo.表名
select * from 本地表 
SQL Server基本函数
SQL Server基本函数
1.字符串函数 长度与分析用
1,datalength(Char_expr) 返回字符串包含字符数,但不包含后面的空格
2,substring(expression,start,length) 取子串，字符串的下标是从“1”，start为起始位置，length为字符串长度，实际应用中以len(expression)取得其长度
3,right(char_expr,int_expr) 返回字符串右边第int_expr个字符，还用left于之相反
4,isnull( check_expression,replacement_value)如果check_expression為空，則返回replacement_value的值，不為空，就返回check_expression字符操作类
5,Sp_addtype自定義數據類型
例如：EXEC sp_addtype birthday, datetime, 'NULL'
6,set nocount {on|off}
使返回的结果中不包含有关受 Transact-SQL 语句影响的行数的信息。如果存储过程中包含的一些语句并不返回许多实际的数据，则该设置由于大量减少了网络流量，因此可显著提高性能。SET NOCOUNT 设置是在执行或运行时设置，而不是在分析时设置。
SET NOCOUNT 为 ON 时，不返回计数（表示受 Transact-SQL 语句影响的行数）。
SET NOCOUNT 为 OFF 时，返回计数
常识
 
在SQL查询中：from后最多可以跟多少张表或视图：256
在SQL语句中出现 Order by,查询时，先排序，后取
在SQL中，一个字段的最大容量是8000，而对于nvarchar(4000),由于nvarchar是Unicode码。  
        
SQLServer2000同步复制技术实现步骤
一、 预备工作
1.发布服务器,订阅服务器都创建一个同名的windows用户,并设置相同的密码,做为发布快照文件夹的有效访问用户
--管理工具
--计算机管理
--用户和组
--右键用户
--新建用户
--建立一个隶属于administrator组的登陆windows的用户（SynUser）
2.在发布服务器上,新建一个共享目录,做为发布的快照文件的存放目录,操作:
我的电脑--D:\ 新建一个目录,名为: PUB
--右键这个新建的目录
--属性--共享
--选择"共享该文件夹"
--通过"权限"按纽来设置具体的用户权限,保证第一步中创建的用户(SynUser) 具有对该文件夹的所有权限
 
--确定
3.设置SQL代理(SQLSERVERAGENT)服务的启动用户(发布/订阅服务器均做此设置)
开始--程序--管理工具--服务
--右键SQLSERVERAGENT
--属性--登陆--选择"此账户"
--输入或者选择第一步中创建的windows登录用户名（SynUser）
--"密码"中输入该用户的密码
4.设置SQL Server身份验证模式,解决连接时的权限问题(发布/订阅服务器均做此设置)
企业管理器
--右键SQL实例--属性
--安全性--身份验证
--选择"SQL Server 和 Windows"
--确定
5.在发布服务器和订阅服务器上互相注册
企业管理器
--右键SQL Server组
--新建SQL Server注册...
--下一步--可用的服务器中,输入你要注册的远程服务器名 --添加
--下一步--连接使用,选择第二个"SQL Server身份验证"
--下一步--输入用户名和密码（SynUser）
--下一步--选择SQL Server组,也可以创建一个新组
--下一步--完成
6.对于只能用IP,不能用计算机名的,为其注册服务器别名（此步在实施中没用到）
 (在连接端配置,比如,在订阅服务器上配置的话,服务器名称中输入的是发布服务器的IP)
开始--程序--Microsoft SQL Server--客户端网络实用工具
--别名--添加
--网络库选择"tcp/ip"--服务器别名输入SQL服务器名
--连接参数--服务器名称中输入SQL服务器ip地址
--如果你修改了SQL的端口,取消选择"动态决定端口",并输入对应的端口号
二、 正式配置
1、配置发布服务器
打开企业管理器，在发布服务器（B、C、D）上执行以下步骤:
(1) 从[工具]下拉菜单的[复制]子菜单中选择[配置发布、订阅服务器和分发]出现配置发布和分发向导 
(2) [下一步] 选择分发服务器 可以选择把发布服务器自己作为分发服务器或者其他sql的服务器（选择自己）
(3) [下一步] 设置快照文件夹
采用默认\\servername\Pub
(4) [下一步] 自定义配置 
可以选择:是,让我设置分发数据库属性启用发布服务器或设置发布设置
否,使用下列默认设置（推荐）
(5) [下一步] 设置分发数据库名称和位置 采用默认值
(6) [下一步] 启用发布服务器 选择作为发布的服务器
(7) [下一步] 选择需要发布的数据库和发布类型
(8) [下一步] 选择注册订阅服务器
(9) [下一步] 完成配置
2、创建出版物
发布服务器B、C、D上
(1)从[工具]菜单的[复制]子菜单中选择[创建和管理发布]命令
(2)选择要创建出版物的数据库，然后单击[创建发布]
(3)在[创建发布向导]的提示对话框中单击[下一步]系统就会弹出一个对话框。对话框上的内容是复制的三个类型。我们现在选第一个也就是默认的快照发布(其他两个大家可以去看看帮助)
(4)单击[下一步]系统要求指定可以订阅该发布的数据库服务器类型,
SQLSERVER允许在不同的数据库如 orACLE或ACCESS之间进行数据复制。
但是在这里我们选择运行"SQL SERVER 2000"的数据库服务器
(5)单击[下一步]系统就弹出一个定义文章的对话框也就是选择要出版的表
注意: 如果前面选择了事务发布 则再这一步中只能选择带有主键的表
(6)选择发布名称和描述
(7)自定义发布属性 向导提供的选择:
是 我将自定义数据筛选,启用匿名订阅和或其他自定义属性
否 根据指定方式创建发布 （建议采用自定义的方式）
(8)[下一步] 选择筛选发布的方式 
(9)[下一步] 可以选择是否允许匿名订阅
1)如果选择署名订阅,则需要在发布服务器上添加订阅服务器
方法: [工具]->[复制]->[配置发布、订阅服务器和分发的属性]->[订阅服务器] 中添加
否则在订阅服务器上请求订阅时会出现的提示:改发布不允许匿名订阅
如果仍然需要匿名订阅则用以下解决办法 
[企业管理器]->[复制]->[发布内容]->[属性]->[订阅选项] 选择允许匿名请求订阅
2)如果选择匿名订阅,则配置订阅服务器时不会出现以上提示
(10)[下一步] 设置快照 代理程序调度
(11)[下一步] 完成配置
当完成出版物的创建后创建出版物的数据库也就变成了一个共享数据库
有数据 
srv1.库名..author有字段:id,name,phone, 
srv2.库名..author有字段:id,name,telphone,adress 
 
要求： 
srv1.库名..author增加记录则srv1.库名..author记录增加 
srv1.库名..author的phone字段更新，则srv1.库名..author对应字段telphone更新 
--*/ 
 
--大致的处理步骤 
--1.在 srv1 上创建连接服务器,以便在 srv1 中操作 srv2,实现同步 
exec sp_addlinkedserver 'srv2','','SQLOLEDB','srv2的sql实例名或ip' 
exec sp_addlinkedsrvlogin 'srv2','false',null,'用户名','密码' 
go
--2.在 srv1 和 srv2 这两台电脑中,启动 msdtc(分布式事务处理服务),并且设置为自动启动
。我的电脑--控制面板--管理工具--服务--右键 Distributed Transaction Coordinator--属性--启动--并将启动类型设置为自动启动 
go 
 
 
--然后创建一个作业定时调用上面的同步处理存储过程就行了 
 
企业管理器 
--管理 
--SQL Server代理 
--右键作业 
--新建作业 
--"常规"项中输入作业名称 
--"步骤"项 
--新建 
--"步骤名"中输入步骤名 
--"类型"中选择"Transact-SQL 脚本(TSQL)" 
--"数据库"选择执行命令的数据库 
--"命令"中输入要执行的语句: exec p_process 
--确定 
--"调度"项 
--新建调度 
--"名称"中输入调度名称 
--"调度类型"中选择你的作业执行安排 
--如果选择"反复出现" 
--点"更改"来设置你的时间安排 
 
 
然后将SQL Agent服务启动,并设置为自动启动,否则你的作业不会被执行 
 
设置方法: 
我的电脑--控制面板--管理工具--服务--右键 SQLSERVERAGENT--属性--启动类型--选择"自动启动"--确定. 
 
 
--3.实现同步处理的方法2,定时同步 
 
--在srv1中创建如下的同步处理存储过程 
create proc p_process 
as 
--更新修改过的数据 
update b set name=i.name,telphone=i.telphone 
from srv2.库名.dbo.author b,author i 
where b.id=i.id and
(b.name <> i.name or b.telphone <> i.telphone) 
 
--插入新增的数据 
insert srv2.库名.dbo.author(id,name,telphone) 
select id,name,telphone from author i 
where not exists( 
select * from srv2.库名.dbo.author where id=i.id) 
 
--删除已经删除的数据(如果需要的话) 
delete b 
from srv2.库名.dbo.author b 
where not exists( 
select * from author where id=b.id)
go


一、了解C#中的预定义事件处理机制

    在写代码前我们先来熟悉.net框架中和事件有关的类和委托，了解C#中预定义事件的处理。
EventArgs是包含事件数据的类的基类,用于传递事件的细节。
EventHandler是一个委托声明如下
public delegate void EventHandler( object sender , EventArgs e )
注意这里的参数,前者是一个对象（其实这里传递的是对象的引用，如果是button1的click事件则sender就是button1），后面是包含事件数据的类的基类。
下面我们研究一下Button类看看其中的事件声明（使用WinCV工具查看），以Click事件为例。
public event EventHandler Click;
这里定义了一个EventHandler类型的事件Click
前面的内容都是C#在类库中已经为我们定义好了的。下面我们来看编程时产生的代码。
private void button1_Click(object sender, System.EventArgs e)
         {
             ...
         }
这是我们和button1_click事件所对应的方法。注意方法的参数符合委托中的签名（既参数列表）。那我们怎么把这个方法和事件联系起来呢，请看下面的代码。
this.button1.Click += new System.EventHandler(this.button1_Click);
把this.button1_Click方法绑定到this.button1.Click事件。
下面我们研究一下C#事件处理的工作流程，首先系统会在为我们创建一个在后台监听事件的对象(如果是 button1的事件那么监听事件的就是button1)，这个对象用来产生事件，如果有某个用户事件发生则产生对应的应用程序事件，然后执行订阅了事件 的所有方法。
二、简单的自定义事件(1)
首先我们需要定义一个类来监听客户端事件，这里我们监听键盘的输入。
定义一个委托。
public delegate void UserRequest(object sender,EventArgs e);
前面的object用来传递事件的发生者，后面的EventArgs用来传递事件的细节，现在暂时没什么用处，一会后面的例子中将使用。
下面定义一个此委托类型类型的事件
 public event UserRequest OnUserRequest;
 下面我们来做一个死循环
 public void Run()
      {
        bool finished=false;
         do
          {
           if (Console.ReadLine()=="h")
           {
            OnUserRequest(this,new EventArgs());
           }  
          }while(!finished);
          }
此代码不断的要求用户输入字符，如果输入的结果是h,则触发OnUserRequest事件，事件的触发者是本身（this），事件细节无(没有传递任何参数的EventArgs实例)。我们给这个类取名为UserInputMonitor。
下面我们要做的是定义客户端的类
    首先得实例化UserInputMonitor类
 UserInputMonitor monitor=new UserInputMonitor();
 然后我们定义一个方法。
 private void ShowMessage(object sender,EventArgs e)
       {
           Console.WriteLine("HaHa!!");
       }
 最后要做的是把这个方法和事件联系起来（订阅事件），我们把它写到库户端类的构造函数里。
Client(UserInputMonitor m)
      {
        m.OnUserRequest+=new    UserInputMonitor.UserRequest(this.ShowMessage);
       //m.OnUserRequest+=new m.UserRequest(this.ShowMessage);
       //注意这种写法是错误的，因为委托是静态的
      }
 下面创建客户端的实例。
  new Client(monitor);
  对了，别忘了让monitor开始监听事件。
  monitor.run();
  大功告成，代码如下：
  using System;
       class UserInputMonitor
      {
        public delegate void UserRequest(object sender,EventArgs e);
       //定义委托
        public event UserRequest OnUserRequest;
       //此委托类型类型的事件
        public void Run()
       {
            bool finished=false;
         do
         {
           if (Console.ReadLine()=="h")
            {
           OnUserRequest(this,new EventArgs());
            }  
         }while(!finished);
     }
}
  public class Client
   {
      public static void Main()
        {
           UserInputMonitor monitor=new UserInputMonitor();
           new Client(monitor);
            monitor.Run();
        }
   private void ShowMessage(object sender,EventArgs e)
     {
        Console.WriteLine("HaHa!!");
     }
     Client(UserInputMonitor m)
       {
         m.OnUserRequest+=new     UserInputMonitor.UserRequest(this.ShowMessage);
         //m.OnUserRequest+=new m.UserRequest(this.ShowMessage);
        //注意这种写法是错误的，因为委托是静态的
        }
    }
三、进一步研究C#中的预定义事件处理机制
    可能大家发现在C#中有些事件和前面的似乎不太一样。例
private void textBox1_KeyPress(object sender,System.Windows.Forms.KeyPressEventArgs e)
       {

       }
 this.textBox1.KeyPress+=newSystem.Windows.Forms.KeyPressEventHandler(this.textBox1_KeyPress);
这里使用了KeyPressEventArgs而不是EventArgs作为参数。这里使用了KeyEventHandler委托，而不是EventHandler委托。
KeyPressEventArgs是EventArgs的派生类，而KeyEventHandler的声明如下
public delegate void KeyEventHandler( object sender , KeyEventArgs e );
是参数为KeyEventArgs的委托。那为什么KeyPress事件要这么做呢，我们可以从两个类的构造函数来找答案。
public EventArgs();
public KeyPressEventArgs(char keyChar);
这里的keyData是什么，是用来传递我们按下了哪个键的，哈。
我在KeyEventArgs中又发现了属性
public char KeyChar { get; }
 进一步证明了我的理论。下面我们来做一个类似的例子来帮助理解。
四、简单的自定义事件(2)
    拿我们上面做的例子来改。
    我们也定义一个EventArgs（类似KeyEventArgs）取名MyEventArgs,定义一个构造函数public MyEventArgs(char keyChar),同样我们也设置相应的属性。代码如下
 
using System;
class MyMyEventArgs:EventArgs
{
 private char keyChar;
 public MyMyEventArgs(char keyChar)
 {
  this.keychar=keychar;
 }
 public char KeyChar
 {
  get
  {
   return keyChar;
  }
 }
}
因为现在要监听多个键了，我们得改写监听器的类中的do...while部分。改写委托，改写客户端传递的参数。好了最终代码如下，好累
using System;
class MyEventArgs:EventArgs
{
 private char keyChar;
 public MyEventArgs(char keyChar)
 {
  this.keyChar=keyChar;
 }
 public char KeyChar
 {
  get
  {
   return keyChar;
  }
 }
}
class UserInputMonitor
{
 public delegate void UserRequest(object sender,MyEventArgs e);
 //定义委托
 public event UserRequest OnUserRequest;
 //此委托类型类型的事件
 public void Run()
 {
  bool finished=false;
  do
  {
   string inputString= Console.ReadLine();
   if (inputString!="") 
    OnUserRequest(this,new MyEventArgs(inputString[0]));
  }while(!finished);
 }
}
public class Client
{
 public static void Main()
 {
  UserInputMonitor monitor=new UserInputMonitor();
  new Client(monitor);
  monitor.Run();
 }
 private void ShowMessage(object sender,MyEventArgs e)
 {
  Console.WriteLine("捕捉到：{0}",e.KeyChar);
 }
 Client(UserInputMonitor m)
 {
  m.OnUserRequest+=new UserInputMonitor.UserRequest(this.ShowMessage);
  //m.OnUserRequest+=new m.UserRequest(this.ShowMessage);
  //注意这种写法是错误的，因为委托是静态的
 }
}


标题: Microsoft SQL Server Management Studio Express
